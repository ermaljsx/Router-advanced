{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\n\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\n\nvar _escapeRegexp = require(\"../../escape-regexp\");\n\nvar _parseUrl = require(\"./parse-url\");\n\nfunction matchHas(req, has, query) {\n  const params = {};\n  const allMatch = has.every(hasItem => {\n    let value;\n    let key = hasItem.key;\n\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n\n      case 'cookie':\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n\n      case 'host':\n        {\n          const {\n            host\n          } = (req === null || req === void 0 ? void 0 : req.headers) || {}; // remove port from host if present\n\n          const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`);\n      const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach(groupKey => {\n              params[groupKey] = matches.groups[groupKey];\n            });\n          } else if (hasItem.type === 'host' && matches[0]) {\n            params.host = matches[0];\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  if (allMatch) {\n    return params;\n  }\n\n  return false;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return (0, _pathToRegexp).compile(`/${value}`, {\n    validate: false\n  })(params).substr(1);\n}\n\nfunction prepareDestination(args) {\n  const query = Object.assign({}, args.query);\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n  let escapedDestination = args.destination;\n\n  for (const param of Object.keys({ ...args.params,\n    ...query\n  })) {\n    escapedDestination = escapeSegment(escapedDestination, param);\n  }\n\n  const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n  const destQuery = parsedDestination.query;\n  const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n  const destHostname = unescapeSegments(parsedDestination.hostname || '');\n  const destPathParamKeys = [];\n  const destHostnameParamKeys = [];\n  (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n  (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n  const destParams = [];\n  destPathParamKeys.forEach(key => destParams.push(key.name));\n  destHostnameParamKeys.forEach(key => destParams.push(key.name));\n  const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n    validate: false\n  }); // update any params in query values\n\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map(value => compileNonPath(unescapeSegments(value), args.params));\n    } else {\n      destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);\n    }\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  let paramKeys = Object.keys(args.params).filter(name => name !== 'nextInternalLocale');\n\n  if (args.appendParamsToQuery && !paramKeys.some(key => destParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = args.params[key];\n      }\n    }\n  }\n\n  let newUrl;\n\n  try {\n    newUrl = destPathCompiler(args.params);\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.hostname = destHostnameCompiler(args.params);\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = { ...query,\n    ...parsedDestination.query\n  };\n  return {\n    newUrl,\n    parsedDestination\n  };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\n\n\nfunction getSafeParamName(paramName) {\n  let newParamName = '';\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n\n    if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n    ) {\n      newParamName += paramName[i];\n    }\n  }\n\n  return newParamName;\n}\n\nfunction escapeSegment(str, segmentName) {\n  return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\n\nfunction unescapeSegments(str) {\n  return str.replace(/__ESC_COLON_/gi, ':');\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/prepare-destination.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _parseUrl = require(\"./parse-url\");\nfunction matchHas(req, has, query) {\n    const params = {\n    };\n    const allMatch = has.every((hasItem)=>{\n        let value;\n        let key = hasItem.key;\n        switch(hasItem.type){\n            case 'header':\n                {\n                    key = key.toLowerCase();\n                    value = req.headers[key];\n                    break;\n                }\n            case 'cookie':\n                {\n                    value = req.cookies[hasItem.key];\n                    break;\n                }\n            case 'query':\n                {\n                    value = query[key];\n                    break;\n                }\n            case 'host':\n                {\n                    const { host  } = (req === null || req === void 0 ? void 0 : req.headers) || {\n                    };\n                    // remove port from host if present\n                    const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n                    value = hostname;\n                    break;\n                }\n            default:\n                {\n                    break;\n                }\n        }\n        if (!hasItem.value && value) {\n            params[getSafeParamName(key)] = value;\n            return true;\n        } else if (value) {\n            const matcher = new RegExp(`^${hasItem.value}$`);\n            const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n            if (matches) {\n                if (Array.isArray(matches)) {\n                    if (matches.groups) {\n                        Object.keys(matches.groups).forEach((groupKey)=>{\n                            params[groupKey] = matches.groups[groupKey];\n                        });\n                    } else if (hasItem.type === 'host' && matches[0]) {\n                        params.host = matches[0];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    });\n    if (allMatch) {\n        return params;\n    }\n    return false;\n}\nfunction compileNonPath(value, params) {\n    if (!value.includes(':')) {\n        return value;\n    }\n    for (const key of Object.keys(params)){\n        if (value.includes(`:${key}`)) {\n            value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n        }\n    }\n    value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*');\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    return (0, _pathToRegexp).compile(`/${value}`, {\n        validate: false\n    })(params).substr(1);\n}\nfunction prepareDestination(args) {\n    const query = Object.assign({\n    }, args.query);\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n    let escapedDestination = args.destination;\n    for (const param of Object.keys({\n        ...args.params,\n        ...query\n    })){\n        escapedDestination = escapeSegment(escapedDestination, param);\n    }\n    const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n    const destQuery = parsedDestination.query;\n    const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n    const destHostname = unescapeSegments(parsedDestination.hostname || '');\n    const destPathParamKeys = [];\n    const destHostnameParamKeys = [];\n    (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n    (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n    const destParams = [];\n    destPathParamKeys.forEach((key)=>destParams.push(key.name)\n    );\n    destHostnameParamKeys.forEach((key)=>destParams.push(key.name)\n    );\n    const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    {\n        validate: false\n    });\n    const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n        validate: false\n    });\n    // update any params in query values\n    for (const [key, strOrArray] of Object.entries(destQuery)){\n        // the value needs to start with a forward-slash to be compiled\n        // correctly\n        if (Array.isArray(strOrArray)) {\n            destQuery[key] = strOrArray.map((value)=>compileNonPath(unescapeSegments(value), args.params)\n            );\n        } else {\n            destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);\n        }\n    }\n    // add path params to query if it's not a redirect and not\n    // already defined in destination query or path\n    let paramKeys = Object.keys(args.params).filter((name)=>name !== 'nextInternalLocale'\n    );\n    if (args.appendParamsToQuery && !paramKeys.some((key)=>destParams.includes(key)\n    )) {\n        for (const key of paramKeys){\n            if (!(key in destQuery)) {\n                destQuery[key] = args.params[key];\n            }\n        }\n    }\n    let newUrl;\n    try {\n        newUrl = destPathCompiler(args.params);\n        const [pathname, hash] = newUrl.split('#');\n        parsedDestination.hostname = destHostnameCompiler(args.params);\n        parsedDestination.pathname = pathname;\n        parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n        delete parsedDestination.search;\n    } catch (err) {\n        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n            throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n        }\n        throw err;\n    }\n    // Query merge order lowest priority to highest\n    // 1. initial URL query values\n    // 2. path segment values\n    // 3. destination specified query values\n    parsedDestination.query = {\n        ...query,\n        ...parsedDestination.query\n    };\n    return {\n        newUrl,\n        parsedDestination\n    };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */ function getSafeParamName(paramName) {\n    let newParamName = '';\n    for(let i = 0; i < paramName.length; i++){\n        const charCode = paramName.charCodeAt(i);\n        if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n        ) {\n            newParamName += paramName[i];\n        }\n    }\n    return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n    return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\nfunction unescapeSegments(str) {\n    return str.replace(/__ESC_COLON_/gi, ':');\n}\n\n//# sourceMappingURL=prepare-destination.js.map"]},"metadata":{},"sourceType":"script"}