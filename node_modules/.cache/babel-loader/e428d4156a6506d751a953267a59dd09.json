{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedRoutes = getSortedRoutes;\n\nclass UrlNode {\n  insert(urlPath) {\n    this._insert(urlPath.split('/').filter(Boolean), [], false);\n  }\n\n  smoosh() {\n    return this._smoosh();\n  }\n\n  _smoosh() {\n    let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n    const childrenPaths = [...this.children.keys()].sort();\n\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n    }\n\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n    }\n\n    const routes = childrenPaths.map(c => this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr) => [...prev, ...curr], []);\n\n    if (this.slugName !== null) {\n      routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n\n      if (this.optionalRestSlugName != null) {\n        throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n      }\n\n      routes.unshift(r);\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n    }\n\n    return routes;\n  }\n\n  _insert(urlPaths, slugNames, isCatchAll) {\n    if (urlPaths.length === 0) {\n      this.placeholder = false;\n      return;\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`);\n    } // The next segment in the urlPaths list\n\n\n    let nextSegment = urlPaths[0]; // Check if the segment matches `[something]`\n\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1);\n      let isOptional = false;\n\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1);\n        isOptional = true;\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3);\n        isCatchAll = true;\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n      }\n\n      function handleSlug(previousSlug, nextSlug) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n            throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n          }\n        }\n\n        slugNames.forEach(slug => {\n          if (slug === nextSlug) {\n            throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n          }\n        });\n        slugNames.push(nextSlug);\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.optionalRestSlugName = segmentName; // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n\n          nextSegment = '[[...]]';\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n          }\n\n          handleSlug(this.restSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.restSlugName = segmentName; // nextSegment is overwritten to [...] so that it can later be sorted specifically\n\n          nextSegment = '[...]';\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n        }\n\n        handleSlug(this.slugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.slugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[]';\n      }\n    } // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n\n\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode());\n    }\n\n    this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n  }\n\n  constructor() {\n    this.placeholder = true;\n    this.children = new Map();\n    this.slugName = null;\n    this.restSlugName = null;\n    this.optionalRestSlugName = null;\n  }\n\n}\n\nfunction getSortedRoutes(normalizedPages) {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode(); // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n\n  normalizedPages.forEach(pagePath => root.insert(pagePath)); // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n\n  return root.smoosh();\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/sorted-routes.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getSortedRoutes = getSortedRoutes;\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split('/').filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix = '/') {\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(`${prefix}${c}/`)\n        ).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ]\n        , []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n        }\n        if (!this.placeholder) {\n            const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(`Catch-all must be the last part of the URL.`);\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith('...')) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n                throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n            }\n            if (segmentName.startsWith('.')) {\n                throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n                    }\n                    if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n                        throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = '[[...]]';\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = '[...]';\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = '[]';\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath)\n    );\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n}\n\n//# sourceMappingURL=sorted-routes.js.map"]},"metadata":{},"sourceType":"script"}