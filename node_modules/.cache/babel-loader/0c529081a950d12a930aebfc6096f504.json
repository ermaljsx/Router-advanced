{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\n\n\nconst MS_MAX_IDLE_DELAY = 3800;\n\nfunction withFuture(key, map, generator) {\n  let entry = map.get(key);\n\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n\n    return Promise.resolve(entry);\n  }\n\n  let resolver;\n  const prom = new Promise(resolve => {\n    resolver = resolve;\n  });\n  map.set(key, entry = {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? generator() // eslint-disable-next-line no-sequences\n  .then(value => (resolver(value), value)).catch(err => {\n    map.delete(key);\n    throw err;\n  }) : prom;\n}\n\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (// detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\nconst canPrefetch = hasPrefetch();\n\nfunction prefetchViaDom(href, as, link) {\n  return new Promise((res, rej) => {\n    const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`;\n\n    if (document.querySelector(selector)) {\n      return res();\n    }\n\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = `prefetch`;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\n\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\n\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\n\nfunction appendScript(src, script) {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script'); // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n\n    script.onload = resolve;\n\n    script.onerror = () => reject(markAssetError(new Error(`Failed to load script: ${src}`))); // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN; // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n\n    script.src = src;\n    document.body.appendChild(script);\n  });\n} // We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\n\n\nlet devBuildPromise; // Resolve a promise that times out after given amount of milliseconds.\n\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise((resolve, reject) => {\n    let cancelled = false;\n    p.then(r => {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    }).catch(reject); // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n\n    if (process.env.NODE_ENV === 'development') {\n      (devBuildPromise || Promise.resolve()).then(() => {\n        (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {\n          if (!cancelled) {\n            reject(err);\n          }\n        }, ms));\n      });\n    }\n\n    if (process.env.NODE_ENV !== 'development') {\n      (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {\n        if (!cancelled) {\n          reject(err);\n        }\n      }, ms));\n    }\n  });\n}\n\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n\n  const onBuildManifest = new Promise(resolve => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB;\n\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\n\nfunction getMiddlewareManifest() {\n  if (self.__MIDDLEWARE_MANIFEST) {\n    return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n  }\n\n  const onMiddlewareManifest = new Promise(resolve => {\n    const cb = self.__MIDDLEWARE_MANIFEST_CB;\n\n    self.__MIDDLEWARE_MANIFEST_CB = () => {\n      resolve(self.__MIDDLEWARE_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\n\nfunction getFilesForRoute(assetPrefix, route) {\n  if (process.env.NODE_ENV === 'development') {\n    return Promise.resolve({\n      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js'))],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n\n  return getClientBuildManifest().then(manifest => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n    }\n\n    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + encodeURI(entry));\n    return {\n      scripts: allFiles.filter(v => v.endsWith('.js')),\n      css: allFiles.filter(v => v.endsWith('.css'))\n    };\n  });\n}\n\nfunction createRouteLoader(assetPrefix) {\n  const entrypoints = new Map();\n  const loadedScripts = new Map();\n  const styleSheets = new Map();\n  const routes = new Map();\n\n  function maybeExecuteScript(src) {\n    // With HMR we might need to \"reload\" scripts when they are\n    // disposed and readded. Executing scripts twice has no functional\n    // differences\n    if (process.env.NODE_ENV !== 'development') {\n      let prom = loadedScripts.get(src);\n\n      if (prom) {\n        return prom;\n      } // Skip executing script if it's already in the DOM:\n\n\n      if (document.querySelector(`script[src^=\"${src}\"]`)) {\n        return Promise.resolve();\n      }\n\n      loadedScripts.set(src, prom = appendScript(src));\n      return prom;\n    } else {\n      return appendScript(src);\n    }\n  }\n\n  function fetchStyleSheet(href) {\n    let prom = styleSheets.get(href);\n\n    if (prom) {\n      return prom;\n    }\n\n    styleSheets.set(href, prom = fetch(href).then(res => {\n      if (!res.ok) {\n        throw new Error(`Failed to load stylesheet: ${href}`);\n      }\n\n      return res.text().then(text => ({\n        href: href,\n        content: text\n      }));\n    }).catch(err => {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n\n  return {\n    whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n\n    onEntrypoint(route, execute) {\n      (execute ? Promise.resolve().then(() => execute()).then(exports => ({\n        component: exports && exports.default || exports,\n        exports: exports\n      }), err => ({\n        error: err\n      })) : Promise.resolve(undefined)).then(input => {\n        const old = entrypoints.get(route);\n\n        if (old && 'resolve' in old) {\n          if (input) {\n            entrypoints.set(route, input);\n            old.resolve(input);\n          }\n        } else {\n          if (input) {\n            entrypoints.set(route, input);\n          } else {\n            entrypoints.delete(route);\n          } // when this entrypoint has been resolved before\n          // the route is outdated and we want to invalidate\n          // this cache entry\n\n\n          routes.delete(route);\n        }\n      });\n    },\n\n    loadRoute(route, prefetch) {\n      return withFuture(route, routes, () => {\n        let devBuildPromiseResolve;\n\n        if (process.env.NODE_ENV === 'development') {\n          devBuildPromise = new Promise(resolve => {\n            devBuildPromiseResolve = resolve;\n          });\n        }\n\n        return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(_ref => {\n          let {\n            scripts,\n            css\n          } = _ref;\n          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n        }).then(res => {\n          return this.whenEntrypoint(route).then(entrypoint => ({\n            entrypoint,\n            styles: res[1]\n          }));\n        }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(_ref2 => {\n          let {\n            entrypoint,\n            styles\n          } = _ref2;\n          const res = Object.assign({\n            styles: styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        }).catch(err => {\n          if (prefetch) {\n            // we don't want to cache errors during prefetch\n            throw err;\n          }\n\n          return {\n            error: err\n          };\n        }).finally(() => {\n          return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n        });\n      });\n    },\n\n    prefetch(route) {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n\n      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script, 'script')) : [])).then(() => {\n        (0, _requestIdleCallback).requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}));\n      }).catch( // swallow prefetch errors\n      () => {});\n    }\n\n  };\n}","map":{"version":3,"sources":["../../client/route-loader.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator()// eslint-disable-next-line no-sequences\n    .then((value)=>(resolver(value), value)\n    ).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// detect IE11 since it supports prefetch but isn't detected\n        // with relList.support\n        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((res, rej)=>{\n        const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`;\n        if (document.querySelector(selector)) {\n            return res();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = `prefetch`;\n        link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        link.onload = res;\n        link.onerror = rej;\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {\n    });\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n        ;\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (process.env.NODE_ENV === 'development') {\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms)\n                );\n            });\n        }\n        if (process.env.NODE_ENV !== 'development') {\n            (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                    if (!cancelled) {\n                        reject(err);\n                    }\n                }, ms)\n            );\n        }\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getMiddlewareManifest() {\n    if (self.__MIDDLEWARE_MANIFEST) {\n        return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n    }\n    const onMiddlewareManifest = new Promise((resolve)=>{\n        const cb = self.__MIDDLEWARE_MANIFEST_CB;\n        self.__MIDDLEWARE_MANIFEST_CB = ()=>{\n            resolve(self.__MIDDLEWARE_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (process.env.NODE_ENV === 'development') {\n        return Promise.resolve({\n            scripts: [\n                assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js')), \n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + '/_next/' + encodeURI(entry)\n        );\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith('.js')\n            ),\n            css: allFiles.filter((v)=>v.endsWith('.css')\n            )\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (process.env.NODE_ENV !== 'development') {\n            let prom = loadedScripts.get(src);\n            if (prom) {\n                return prom;\n            }\n            // Skip executing script if it's already in the DOM:\n            if (document.querySelector(`script[src^=\"${src}\"]`)) {\n                return Promise.resolve();\n            }\n            loadedScripts.set(src, prom = appendScript(src));\n            return prom;\n        } else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then((res)=>{\n            if (!res.ok) {\n                throw new Error(`Failed to load stylesheet: ${href}`);\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                })\n            );\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            (execute ? Promise.resolve().then(()=>execute()\n            ).then((exports)=>({\n                    component: exports && exports.default || exports,\n                    exports: exports\n                })\n            , (err)=>({\n                    error: err\n                })\n            ) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (process.env.NODE_ENV === 'development') {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(({ scripts , css  })=>{\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet)), \n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        })\n                    );\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({ entrypoint , styles  })=>{\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>{\n                    return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script, 'script')\n                ) : [])\n            ).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{\n                    })\n                );\n            }).catch(// swallow prefetch errors\n            ()=>{\n            });\n        }\n    };\n}\n\n//# sourceMappingURL=route-loader.js.map"]},"metadata":{},"sourceType":"script"}